# 09. 옵티마이저와 힌트

---

## 9.1 개요

---

실행 계획을 이해하는 것은 상당히 어렵다. 하지만 실행 계획을 이해할 수 있어야만 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 9.1.1 쿼리 실행 절차

---

MySQL 서버에서 쿼리가 실행되는 과정은 크게 3단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번쨰 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저의 종류

---

옵티마이저는 크게 2가지로 나눌 수 있다.

1. 현재 대부분의 DBMS가 선택하는 비용 기반 최적화.
2. 예전 초기 버전의 오라클 DBMS에서 많이 사용했던 규칙 기반 최적화 방법.

각 옵티마이저의 특징은 다음과 같다.

1. 비용 기반 최적화 : 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다. 산출된 실행 방법별로 비용이
   최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.
2. 규칙 기반 최적화 : 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.

## 9.2 기본 데이터 처리

---

DBMS들은 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. 하지만 그 결과를 만들어 내는 과정은 천차만별이다. MySQL 서버가 어떤 알고리즘을 사용하는지 살펴보자.

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

---

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.

* 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
* WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

MySQL의 InnoDB에서 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.

리드 어헤드는 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미한다.
즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다.

### 9.2.2 병렬 처리

---

MySQL 8.0 버전부터는 용도가 제한되어있지만 병렬 처리가 가능해졌다.

### 9.2.3 ORDER BY 처리(Using filesort)

---

Filesort는 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. 하지만 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

또한 다음의 이유로 모든 정렬에 인덱스를 사용할 수 없다.

* 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우

### 9.2.3.1 소트 버퍼

---

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.

만약에 소트 버퍼보다 큰 레코드를 정렬해야할경우 어떻게 처리할까?
MySQL에서는 레코드들을 여러개의 조각으로 나눈후에 이 조각을 소트하고 디스크에 임시로 저장한다. 그 다음에 디스크에서 가져와 다시 정렬하고 이 과정을 계속 반복한다.
이러한 과정으로 이내 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많아질수록 이 작업의 수는 많아진다.

또한 소트 버퍼는 글로벌 메모리영역이 아닌 세션 메모리 영역에 해당하므로 커넥션이 많아질수록 소트 버퍼가 소비하는 메모리 영역이 커지게 된다.

### 9.2.3.2 정렬 알고리즘

---

MySQL은 싱글 패스, 투 패스 2가지 정렬 모드로 나눌 수 있다.

### 9.2.3.2.1 싱글 패스 정렬 방식

---

소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.

### 9.2.3.2.2 투 패스 정렬 방식

---

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬방식이다.

### 9.2.3.3 정렬 처리 방법

---

|          정렬 처리 방법           |       실행 계획의 Extra 칼럼 내용        |
|:---------------------------:|:-------------------------------:|
|         인덱스를 이용한 정렬         |            별도 표기 없음             |
|      조인에서 드라이빙 테이블만 정렬      |         Using filesort          |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary; Using filesort |

위에서 아래로 갈수록 처리 속도는 떨어진다.

### 9.2.3.3.1 인덱스를 이용한 정렬

---

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE절에 첫 번쨰로 읽는 테이블의 칼럼에
대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

---

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어나고, 레코드 하나하나의 크기도 늘어 난다. 그래서 조인을 실행하기 전에 첫 번쨰 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이
될 것이다.

이 방법으로 정렬이 처리되려면 조인에서 첫 번쨰로 읽히는 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.

### 9.2.3.3.3 임시 테이블을 이용한 정렬

---

2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
앞에서의 드라이빙 테이블을 이용한 방식 외에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.

### 9.2.3.3.4 정렬 처리 방법의 성능 비교

---

일반적인 상황에서 LIMIT을 사용하면 MySQL 서버에 부담을 줄여줄 수 있다. 하지만 ORDER BY, GROUP BY가 추가되면 전체 레코드에 대해 처리를 진행한다음 LIMIT을 처리할 수 있으므로 성능이
저하될 수 있다.

### 9.2.3.3.4.1 스트리밍 방식

---

스트리밍 방식은 클라이언트의 쿼리의 조건과 일치하는 레코드가 검색될때마다 바로바로 클라인트로 전송해주는 방식을 의미한다.

### 9.2.3.3.4.2 버퍼링 방식

---

ORDER BY, GROUP BY는 쿼리의 결과가 스트링되는 것을 불가능하게 한다. 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그로핑해서 차례대로 보내야 하기 때문이다.

MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다.

앞에서 설명한 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후에 정렬된다.

### 9.2.3.4 정렬 관련 상태 변수

---

MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼간의 병합 적업은 몇 번이나 발생했는지
등을 확인할 수 있다.

### 9.2.4 GROUP BY 처리

---

GROUP BY는 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나다.GROUP BY 절이 있는 쿼리에서는 HAVING 정을 사용할 수 있는데, HAVING 절은 GROUP BY 결과에
대해 필터링 역할을 수행한다.

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다.

인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다.
그리고 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

---

ORDER BY의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼을 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서
그루핑 작업을 수행하고 그 결과로 조인을 처리한다.

### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY

---

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하는데, 옵티마이저가 루스 인덱스 스캔을 사용할 떄는 실행 계획의 Extra 칼럼에 "Using index for
group-by"라고 표시된다.

MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다. 또한 프리픽스 인덱스는 루스 인덱스 스캔을 사용할 수 없다.

### 9.2.4.3 임시 테이블을 사용하는  GROUP BY

---

GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.

### 9.2.5 DISTINCT 처리

---

특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다.

### 9.2.5.1 SELECT DISTINCT ...

---

단순히 SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다. 이 경우 GROUP BY와 동일한 방식으로 처리된다. 특히 MySQL 8.0
버전부터는 GROUP BY를 수행하는 쿼리에 ORDER BY 절이 없으면 정렬을 사용하지 않기 때문에 다음의 두 쿼리는 내부적으로 같은 작업을 수행한다.

### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT

---

count(), MIN(),MAX()와 같은 집합 삼수 내에서 DISTINCT 키워드가 사용될 수 있는데, 이 경우에는 일반적으로 SELECT DISTINCT와 다른 형태로 해성된다. 집합 함수가 없는 SELECT
쿼리에서 DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져온다.하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

### 9.2.6 내부 임시 테이블 활용

---

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.

일반적으로 MySQL 엔진이 사용하는 임시 테이블을 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.

MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다.
또한 쿼리의 처리가 완려되면 자동으로 삭제된다.

### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

---

MySQL 8.0 버전부터는 메모리는 TempTable이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB를 사용하도록 개선됐다.

### 9.2.6.2 임시 테이블이 필요한 쿼리

---

* ORDER BY, GROUP BY에 명시된 칼럼이 다른 쿼리
* ORDER BY, GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
* DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
* UNION이나 UNION DISTINCT가 사용된 쿼리
* 쿼리의 실행 계획에서 select_type이 DERIVED인 경우

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

---

* UNION, UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
* GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
* 메모리 임시 테이블의 크기가 시스템변수보다 큰 경우

### 9.2.6.4 임시 테이블 관련 상태 변수

---

"Using temporary"라는 값이 나오면 임시 테이블을 사용했다는 의미이다.
하지만 한번 표시됐다고 해서 임시 테이블을 하나만 사용했다는 것을 의미하지 않는다.

* Created_tmp_disk_tables : 디스크에 생성된 임시 테이블의 수
* Created_tmp_tables : 메모리에 생성된 임시 테이블의 수
  위 두가지 값을 통해 임시 테이블의 생성 횟수에 대해서 알 수 있다.

## 9.3 고급 최적화

---

MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다.

옵티마이저 옵션은 크게 옵티마이저 옵션과 옵티마이저 스위치로 구분하 수 있다.

### 9.3.1 옵티마이저 스위치 옵션

---

옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용해서 제어한다. 이는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.

### 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)

---

MRR은 Multi-Range Read의 약자로서, 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인버퍼에 버퍼링한다. 즉, 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인
대상을 버퍼링하는 것이다. 이렇게 함으로써 스토리지 엔진을 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있는 것이다.
물론 데이터 페이지가 메모리에 있다고 하더라도 버퍼 풀의 접근을 최소화할 수 있는 것이다.

### 9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)

---

MySQL 사용되는 대부분의 조인은 네스티드 루프 조인인데, 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.

### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)

---

인덱스 컨디션 푸시다운은 MySQL 5.6 버전부터 사용되는 옵션이다. 이 옵션은 MySQL 엔진이 조인 처리에서 인덱스에 포함된 칼럼의 조건이 있다면 같이 모아 스토리지 엔진에 전달한 후에 조건을 처리하도록 했다.
버전 5.6 이전에는 스토리지 엔진에 모두 전달할 수없었기에 불필요한 읽기가 발생했었다.

### 9.3.1.4 인덱스 확장

---

use_index_extensions 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.

### 9.3.1.5 인덱스 머지(index_merge)

---

인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다. 하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해
쿼리를 처리한다.

### 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)

---

인덱스 머지의 교집합을 사용하는 경우에는 한 테이블의 2개의 인덱스가 있고 쿼리에서 조건절에 각 인덱스에 대한 조건이 있을 때 사용한다.
이렇게 두 개의 인덱스를 교집합으로 사용한다면 하나의 인덱스를 통해 값을 검색하고 가져오는것보다 불필요한 검색의 수를 줄일 수 있다.

### 9.3.1.7 인덱스 머지-합집합(index_merge_union)

---

합집합의 경우 2개 이상의 조건이 각각의 인덱스를 사용하되 or 연산자로 연결된 경우에 사용되는 최적화다.

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)

---

인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 'Sort Union'알고리즘을 사용한다.

### 9.3.1.9 세미 조인(semijoin)

---

다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라고 한다.

세미 조인 쿼리에 대해 최적화 방법이 있다.

1. 세미 조인 최적화
2. IN-to-EXISTS 최적화
3. MATERIALIZATION 최적화

그리고 <>형태와 NOT IN 형태의 안티 세미 조인 쿼리에 대해서는 다음 2가지 최적화 방법이 있다.

1. IN-to-EXISTS 최적화
2. MATERIALIZATION 최적화

MySQL 서버의 최적화 전략들을 모아 세미 조인 최적화라고 한다.

* Table Pullout
* Duplicate Weedout
* First Match
* Loose Scan
* Materialization

### 9.3.1.10 테이블 풀-아웃(Table Pull-out)

---

Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 죄적화다.
이는 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이였다.

### 9.3.1.11 퍼스트 매치(firstmatch)

---

First match 최적화 전략은 IN 형태의 세미 조인을 EXISTS 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

### 9.3.1.12 루스 스캔(loosescan)

---

세미 조인 서브쿼리 최적화의 LooseScan은 인덱스를 사용하는 GROUP BY 최적화 방법에서 살펴본 "Using index for group-by"의 루스 인덳스 스캔과 비슷한 읽기 방식을 사용한다.

### 9.3.1.13 구체화(Materialization)

---

구체화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다.
구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미한다.

구체화는 다른 서브쿼리 최적화와는 달리, 서브쿼리 내에 GROUP BY 절이 있어도 이 최적화 전략을 사용할 수 있다.

### 9.3.1.14 중복 제거(Duplicated Weed-out)

---

중복 제거는 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.

### 9.3.1.15 컨디션 팬아웃(condition_fanout_filter)

---

조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다.그래서 MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다. 이를 컨디션
팬아웃이라고 한다.

### 9.3.1.16 파생 테이블 머지(derived_merge)

---

예전 버전의 MySQL 서버에서는 FROM 절에서 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리했다.
이떄 임시 테이블의 크기가 커지면 메모리가 아닌 디스크에 저장되므로 디스크 I/O로 인해 성능이 좋지 않다.

MySQL 5.7 부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입됐다. 여기서 derived_merge는 이 최적화 활성 여부를 결정한다.

### 9.3.1.17 인비저블 인덱스(use_invisible_indexes)

---

MySQL 8.0 부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다.

### 9.3.1.18 스킵 스캔(skip_scan)

---

인덱스의 핵심은 값이 정렬돼 있는다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
하지만 인덱스 스캔은 제한적이긴 하지만 인덱스의 이런 제약 사항을 뛰어넘을 수 있는 최적화 기법이다.

### 9.3.1.19 해시 조인(hash_join)

---

MySQL 8.0.18 부터 해시 조인이 추가로 지원되기 시작했다.

해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다.
즉, 해시 조인 쿼리는 최고 스루풋 전략에 적합하며, 네스티드 루프 조인은 최고 응답 속도 전략에 적합하다는 것을 알 수 있다.

### 9.3.1.20 인덱스 정렬 선호(prefer_ordering_index)

---

MySQL 옵티마이저는 ORDER BY, GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계왹에서 이 인덱스의 가중치를 높이 설정해서 실행된다.
하지만 MySQL 옵티마이저가 가끔 실수를 하는 경우가 있기에 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 prefer_ordering_index 옵티마이저 옵션이 추가됐다.

### 9.3.2 조인 최적화 알고리즘

---

MySQL에는 최적화된 조인 실행 계획 수립을 위한 2가지 알고리즘이 있다.

### 9.3.2.1 Exhaustive 검색 알고리즘

---

Exhaustive 검색 알고리즘은 MySQL 5.0 이전에 사용되던 조인 최적화 기업으로, FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.

### 9.3.2.2 Greedy 검색 알고리즘

---

Greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 단점을 보완하기 위해 MySQL 5.0 부터 사용되기 시작한 알고리즘이다.

## 9.4 쿼리 힌트

---

MySQL의 통계 정보나 옵티마이저의 최적화 방법이 다양해지면서 쿼리의 실행 계획 최적화가 많이 성숙해지고 있다. 하지만 서비스 개발자나 DBA가 MySQL의 부족한 실행 계획을 수립할 때가 있을 수 있다. 이런
경우에는 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 방법이 필요하다.

* 인덱스 힌트
* 옵티마이저 힌트

### 9.4.1 인덱스 힌트

---

STRAIGHT_JOIN, USE INDEX 등을 포함한 인덱스 힌트들을 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이다.
하지만 이는 ANSI-SQL 표준 문법에 준수하지 못하게되는 단점이 있다.

MySQL 5.6 버전부터 추가되기 시작한 옵티마이저 힌트들을 모두 MySQL 서버를 제외한 다른 DBMS에서는 주석으로 해석하기 떄문에 문법을 준수한다.
또한 힌트는 SELECT, UPDATE 명령에만 사용할 수 있다.

### 9.4.1.1 STRAIGHT_JOIN

---

STRAIGHT_JOIN은 옵티마이저 힌트인 동시에 조인 키워드이기도 하다. STRAIGHT_JOIN은 SELECT,UPDATE,DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을
한다.

### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX

---

조인의 순서를 변경하는 것 다음으로 자주 사용되는 것이 인덱스 힌트인데, STRAIGHT_JOIN 힌트와는 달리 인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.
가끔 옵티마이저가 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우에는 실수하는데 이떄 강제로 특정 인덱스를 사용하도록 힌트를 추가한다.

* USE INDEX : 가장 자주 사용되는 인덱스 힌트로, 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트
* FORCE INDEX : USE INDEX와 동일한 기능을 수행하지만, FORCE INDEX는 옵티마이저에게 미치는 영향이 더 강한 힌트로 생각하면 된다.
* IGNORE INDEX : USE INDEX와 FORCE INDEX와는 반대로 옵티마이저에게 특정 테이블의 인덱스를 사용하지 않도록 권장하는 힌트

### 9.4.1.3 SQL_CALC_FOUND_ROWS

---

SQL_CALC_FOUND_ROWS가 포함된 쿼리의 경우 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.
하지만 SQL_CALC_FOUND_ROWS을 사용하는 경우 많이 느리다. 그 이유는 일반적인 카운트 쿼리와는 다르게 전체 데이터에 대해서 카운트를 수행하므로 많은 디스크 I/O가 발생하기 때문이다.

### 9.4.2 옵티마이저 힌트

---

### 9.4.2.1 옵티마이저 힌트 종류

---

* 인덱스 : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
* 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
* 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
* 글로벌 : 전체 쿼리에 대해서 영향을 미치는 힌트

### 9.4.2.2 MAX_EXECUTION_TIME

---

옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트이며, 단순히 쿼리의 최대 실행시간을 설정하는 힌트다.

### 9.4.2.3 SET_VAR

---

MySQL 서버의 옵티마이저는 조인 버퍼의 공간이 충분하면 조인 버퍼를 활용하는 형태의 실행 계획을 선택할 수도 있다. 그뿐만아니라 옵티마이저 힌트로 부족한 경우 optimizer_switch 시스템 변수를 제어해야
할 수도 있다. 이런 경우에는 SET_VAR 힌트를 사용한다.

### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN

---

| 최적화 전략             | 힌트                        |
|:-------------------|:--------------------------|
| Duplicate Weed-out | SEMIJOIN(DUSPWEEDOUT)     |
| FirstMatch         | SEMIJOIN(FIRSTMATCH)      |
| Loose Scan         | SEMIJOIN(LOOSESCAN)       |
| Materialization    | SEMIJOIN(MATERIALIZATION) |
| Table Pull-out     | 없음                        |

### 9.4.2.5 SUBQUERY

---

서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법으로, 서브쿼리는 다음 2가지 형태로 최적화할 수 있다.

| 최적화 방법          | 힌트                        |
|:----------------|:--------------------------|
| IN-to-EXISTS    | SUBQUERY(INTOEXISTS)      |
| Materialization | SUBQUERY(MATERIALIZATION) |

세미 조인 최적화는 주로 IN 형태의 쿼리에 사용될 수 있지만 안티 세미 조인의 최적화에는 사용될 수 없다.
그래서 안티 세미 조인 최적화에는 위 2가지 최적화가 사용된다.

### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

---

해시조인은 기존의 블록 네스티드 루프 조인까지 대체하도록 개선되었다. 그래서 MySQL 8.0.20 버전부터는 네스티드 루프 조인은 MySQL 서버에서 더 이상 사용되지 않는다.

하지만 BNL, NO_BNL 힌트는 여전히 사용가능하다. 이 힌트들은 해시 조인을 사용하도록 유도하는 힌트로 용도가 변경됐다. 대신 HASHJOIN, NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만
유효하며, 그 이후버전에서는 효력이 없다.

### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX

---

* JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 싱행하게 하는 힌트
* JOIN_ORDER : FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
* JOIN_PREFIX : 조인에서 드라이빙 테이블만 강제하는 힌트
* JOIN_SUFFIX : 조인에서 드리븐 테이블만 강제하는 힌트

### 9.4.2.8 MERGE & NO_MERGE

---

MERGE, NO_MERGE를 통해서 내부에 임스 테이블을 생성하는 것에 대해 힌트를 줄 수 있다.

### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE

---

MySQL은 테이블당 하나의 인덱스만을 사용해서 쿼리를 처리하려 하지만, 하나의 인덱스만으로 검색 대상 범위를 충분히 좁힐 수 없다면 MySQL 옵티마이저는 사용 가능한 다른 인덱스를 이용하기도 한다.

### 9.4.2.10 NO_ICP

---

인덱스 컨디션 푸시다운(ICP) 최적화는 사용가능하다면 항상 성능 향상에 도움이 되므로 MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립한다. 그래서 MySQL
옵티마이저에서는 ICP 힌트는 제공되지 않는다. 그런데 컨디션 푸시다운으로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.

이에 대해서 ICP 비활성화 힌트를 통해 조금 더 유연하고 정확하게 실행 계획을 선택할 수 있다.

### 9.4.2.11 SKIP_SCAN & NO_SKIP_SCAN

---

인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능이다.
하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 선응은 오히려 더 떨어진다.
따라서 옵티마이저 힌트를 통해 인덱스 스킵 스캔을 사용하지 않게 할 수 있다.

### 9.4.2.12 INDEX & NO_INDEX

---

INDEX, NO_INDEX 옵티마이저 힌트는 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공한다.

| 인덱스 힌트                    | 옵티마이저 힌트       |
|:--------------------------|:---------------|
| USE INDEX                 | INDEX          |
| USE INDEX FOR GROUP BY    | GROUP_INDEX    |
| USE INDEX FOR ORDER BY    | ORDER_INDEX    |
| IGNORE INDEX              | NO_INDEX       |
| IGNORE INDEX FOR GROUP BY | NO_GROUP_INDEX |
| IGNORE INDEX FOR ORDER BY | NO_ORDER_INDEX |
